\documentclass{article}

\usepackage{multicol}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
%\usepackage{natbib} % Required to change bibliography style to APA
%\usepackage{amsmath} % Required for some math elements
%{
%      \newtheorem{assumption}{Assumption}
%      \newtheorem{problem}{Problem}
%}
\usepackage{xcolor}
%\usepackage[usenames,dvipsnames]{color}

\usepackage{ulem}
\usepackage{cancel}

\usepackage{amsthm}
\usepackage{amsmath} % Required for some math elements
{
      \newtheorem{definition}{Definition}
      \newtheorem{assumption}{Assumption}
      \newtheorem{problem}{Problem}
      \newtheorem{lemma}{Lemma}
      \newtheorem{theorem}{Theorem}
      \newtheorem{claim}{Claim}
}
\usepackage{algorithm}
\usepackage{algorithmic}
%\renewcommand{\algorithmicrequire}{ \textbf{Input:}} %Use Input in the format of Algorithm
%\renewcommand{\algorithmicensure}{ \textbf{Output:}} %UseOutput in the format of Algorithm
%\usepackage[linesnumbered,vlined,ruled]{algorithm2e}
\usepackage{graphicx}

\usepackage{cite}
%\usepackage{hyperref}
%\usepackage[numbers,sort&compress]{nat}

\usepackage{xcolor}
%\usepackage[usenames,dvipsnames]{color}
%\usepackage{mathrsfs}
\usepackage{amsfonts,amssymb}

%\usepackage{ulem}
%\usepackage{cancel}

\newcommand{\lyp}[1]{\textcolor{red}{#1}}

%\usepackage{indentfirst}
\setlength\parindent{1em} % Removes all indentation from paragraphs

\usepackage{listings}          % format code

\lstset{ %
language=Haskell,                % choose the language of the code
columns=flexible,
lineskip=-1pt,
basicstyle=\ttfamily\small,       % the size of the fonts that are used for the code
numbers=none,                   % where to put the line-numbers
numberstyle=\ttfamily\tiny,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
morekeywords={var},
%  frame=single,                   % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
captionpos=none,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting; also try caption instead of title
escapeinside={(*}{*)},          % if you want to add a comment within your code
keywordstyle=\ttfamily\bfseries,
% commentstyle=\color{Gray},
% stringstyle=\color{Green}
}


%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Embedded Domain-Specific Languages:\\ Composable Interpretations with Dependencies} % Title
%\author{Name¢} % Author name

\begin{document}

\maketitle % Insert the title, author and date

\begin{abstract}

\end{abstract}

\section{Introduction}

\section{Composable Interpretations}
Additional interpretations can be added naturally for deep embedding. For instance, if we also want to obtain the depth of a circuit, we can define the following interpretation easily.

\begin{verbatim}
newtype Depth = Depth {depth :: Int}

depthAlg :: CircuitF Depth -> Depth
depthAlg (Identity w)   = Depth 0
depthAlg (Fan w)        = Depth 1
depthAlg (Above x y)	   = Depth (depth x + depth y)
depthAlg (Beside x y)   = Depth (depth x `max` depth y)
depthAlg (Stretch xs x) = Depth (depth x)
\end{verbatim}

However, with shallow embedding, circuits can only have a single semantic domain. Pairing semantics up can provide two interpretations simultaneously \cite{1}, but it is still clumsy and not modular: existing code needs to be revised every time a new interpretations is added. Moreover, for more than two interpretations, we have to either create combinations for each pair of interpretations, or use tuples which generally lack good language support \cite{1}. To allow defining and composing multiple interpretations modularly, we first use a type class to represent the shallow embedding

\begin{verbatim}
class Circuit circuit where
  identity :: Int -> circuit
  fan      :: Int -> circuit
  above    :: circuit -> circuit -> circuit
  beside   :: circuit -> circuit -> circuit
  stretch  :: [Int] -> circuit -> circuit
\end{verbatim}

Each interpretation corresponds to an instance of the type class for the type of that interpretation. The \textbf{newtype} wrapper is needed to allow multiple interpretations over the same underlying type.  For example, we can define "width" and "depth" interpretations as follows:

\begin{verbatim}
newtype Width     = Width     {width :: Int}
newtype Depth     = Depth     {depth :: Int}

instance Circuit Width where
  identity w   = Width w
  fan w        = Width w
  above x y    = x
  beside x y   = Width (gwidth x + gwidth y)
  stretch xs x = Width (sum xs)

instance Circuit Depth where
  identity w   = Depth 0
  fan w        = Depth 1
  above x y    = Depth (gdepth x + gdepth y)
  beside x y   = Depth (depth x `max` gdepth y)
  stretch xs x = x
\end{verbatim}

To state that the semantic domain type i represents is part of a larger collection of types, we use the following type class

\begin{verbatim}
class i :<: e where
  inter :: e -> i
\end{verbatim}

We further define an instance for circuit composition, which gives a semantic domain of type (i1, i2) for the interpretation

\begin{verbatim}
type Compose i1 i2 = (i1, i2)

instance (Circuit i1, Circuit i2) => Circuit (Compose i1 i2) where
  identity w   = (identity w, identity w) 
  fan w        = (fan w, fan w)
  above x y    = (above (inter x) (inter y), above (inter x) (inter y))
  beside x y   = (beside (inter x) (inter y), beside (inter x) (inter y))
  stretch xs x = (stretch xs (inter x), stretch xs (inter x))
\end{verbatim}

Following is the construction of the Brent-Kung parallel prefix circuit:

\begin{verbatim}
c1 :: Circuit circuit => circuit
c1 = (fan 2 `beside` fan 2) `above`
     stretch [2,2] (fan 2) `above`
     (identity 1 `beside` fan 2 `beside` identity 1)
\end{verbatim}

\textit{gwidth} and \textit{gdepth} are defined to recover individual interpretations:

\begin{verbatim}
gwidth :: (Width :<: e) => e -> Int
gwidth = width . inter

gdepth :: (Depth :<: e) => e -> Int
gdepth = depth . inter
\end{verbatim}

Then we can use the above functions to get  different properties of c1, depending on its type. For example, \textit{gwidth (c1 :: Compose Width Depth)} and \textit{gdepth (c1 :: Compose Width Depth)} will give us its width and depth,  respectively. 

\section{Dependent interpretations}
The composable interpretation for shallow embedding in the previous section works well with independent circuits. However, when an interpretation depends on other interpretations, the previous approach becomes clumsy as well. 
For example, whether a circuit is well-formed or not depends on the widths of its parts. A new instance for the type \textit{(Compose WellSized width)} is defined to capture this property.

\begin{verbatim}
newtype WellSized = WellSized {wellSized :: Bool}

instance (Circuit width, Width :<: width) => 
          Circuit (Compose WellSized width) where
  identity w   = (WellSized True, identity w)
  fan w        = (WellSized True, fan w)
  above x y    = (WellSized (gwellSized x && gwellSized y 
                             && (gwidth x == gwidth y)),
                  above (inter x) (inter y))
  beside x y   = (WellSized (gwellSized x && gwellSized y),
                  beside (inter x) (inter y))
  stretch xs x = (WellSized (gwellSized x && length xs == gwidth x),
                  stretch xs (inter x))
                  
gwellSized :: (WellSized :<: e) => e -> Bool
gwellSized = wellSized . inter
\end{verbatim}
However, with this approach, we still need to write out the interpretation for \textit{width} together with that for \textit{WellSized}. Instead of explicitly composing two interpretations together when one depends on the other, we want to rely solely on generic composition defined earlier, regardless of whether the two interpretations are independent or not. 

\subsection{Type classes with proxies}
One way is to differentiate between input and output semantic domains. By expressing that the type of output domain is part of the type of input domain, we no longer need to output a pair of interpretations for the dependent case. Let's start with a multi-parameter type class for circuit construction.

\begin{verbatim}
class Circuit inn out where
  identity :: Proxy inn -> Int -> out
  fan      :: Proxy inn -> Int -> out
  above    :: inn       -> inn -> out
  beside   :: inn       -> inn -> out
  stretch  :: [Int]     -> inn -> out
  
data Proxy a = Proxy
\end{verbatim}

The interpretation for \textit{WellSized} can thus be defined in a nicer way:

\begin{verbatim}
instance (Circuit inn WellSized, Width :<: inn, WellSized :<: inn) => 
          Circuit inn WellSized where
  identity (Proxy :: Proxy inn) w = WellSized True
  fan      (Proxy :: Proxy inn) w = WellSized True
  above x y    = WellSized (gwellSized x && gwellSized y 
                            && gwidth x == gwidth y)
  beside x y   = WellSized (gwellSized x && gwellSized y)
  stretch xs x = WellSized (gwellSized x && length xs == gwidth x)
\end{verbatim}

We also need to modify the instance for circuit composition:
 
 \begin{verbatim}
instance (Circuit inn inn1, Circuit inn inn2) => 
          Circuit inn (Compose inn1 inn2) where
  identity (Proxy :: Proxy inn) w = 
           ((identity (Proxy :: Proxy inn) w) :: inn1,
            (identity (Proxy :: Proxy inn) w) :: inn2)
  fan      (Proxy :: Proxy inn) w = 
           ((fan (Proxy :: Proxy inn) w)      :: inn1,
            (fan (Proxy :: Proxy inn) w)      :: inn2)
  above x y    = ((above x y)    :: inn1, (above x y)    :: inn2)
  beside x y   = ((beside x y)   :: inn1, (beside x y)   :: inn2)
  stretch xs x = ((stretch xs x) :: inn1, (stretch xs x) :: inn2)
 \end{verbatim}

The only problem is that due to the restriction of Haskell's type classes, all of the class type variables must be reachable from the free variables of each method type\cite{2}. Therefore, we need the Proxy here for \textit{identity} and \textit{fan} to allow the use of class type \textit{inn}. Also, explicit type annotations are needed for circuit composition.

\subsection{Records}
Another way is to use records to represent circuits. This approach allows us to define dependent interpretations nicely and alleviate us from the pain of using explicit type annotations everywhere. We define the following data type with record syntax for circuit construction:

\begin{verbatim}
data Circuit inn out = Circuit {
  identity :: Int -> out,
  fan      :: Int -> out,
  above    :: inn -> inn -> out,
  beside   :: inn -> inn -> out,
  stretch  :: [Int] -> inn -> out
}
\end{verbatim}

Each interpretation corresponds to a value of the data type. For example, to see whether a circuit is well-formed or not, we define the value \textit{wsAlg}:

\begin{verbatim}
wsAlg :: (Width :<: inn, WellSized :<: inn) => Circuit inn WellSized
wsAlg = Circuit {
  identity = \w    -> WellSized True,
  fan      = \w    -> WellSized True,
  above    = \x y  -> WellSized (gwellSized x && gwellSized y && 
                                 gwidth x == gwidth y),
  beside   = \x y  -> WellSized (gwellSized x && gwellSized y),
  stretch  = \xs x -> WellSized (gwellSized x && length xs == gwidth x)
}
\end{verbatim}

Circuit composition can also be defined as a value of the data type:

\begin{verbatim}
(<+>) :: (inn1 :<: inn, inn2 :<: inn) => 
         Circuit inn inn1 -> Circuit inn inn2 -> Circuit inn (Compose inn1 inn2)
(<+>) a1 a2 = Circuit {
  identity = \w    -> (identity a1 w, identity a2 w),
  fan      = \w    -> (fan a1 w, fan a2 2),
  above    = \x y  -> (above a1 (inter x) (inter y), above a2 (inter x) (inter y)),
  beside   = \x y  -> (beside a1 (inter x) (inter y), beside a2 (inter x) (inter y)),
  stretch  = \xs x -> (stretch a1 xs (inter x), stretch a2 xs (inter x))
}
\end{verbatim}

Now we can compose multiple interpretations smoothly. For example, we can compose individual interpretations \textit{widthAlg}, \textit{depthAlg} and \textit{wsAlg} together to get a new value  \textit{cAlg} for composed interpretation:

\begin{verbatim}
cAlg :: Circuit (Compose Depth (Compose Width WellSized)) 
                (Compose Depth (Compose Width WellSized))
cAlg = depthAlg <+> (widthAlg <+> wsAlg)
\end{verbatim}

\section{Extensibility in Both Dimensions}
So far we've only talked about extensibility in one dimension: 

\subsection{F-Algebras}
We've shown that the type class

\begin{verbatim}
class i :<: e where
  inter :: e -> i
\end{verbatim}

works well with both composable and dependent interpretations for shallow embedding. In this section, we will show that it also allows adding and composing interpretations modularly for deep embedding. We will still use the CircuitF functor for circuit construction, while incorporating our observation functions (i.e. algebras for CircuitF) with the above type class. An algebra for CircuitF is defined as:

\begin{verbatim}
type GAlg r a = CircuitF r -> a
\end{verbatim}

It consists of type r and a, and a function taking a CircuitF of r-values to an a-value. For example, algebras for \textit{width} and \textit{wellSized} can be defined as follows:

\begin{verbatim}
widthAlg :: (Width :<: r) => GAlg r Width
widthAlg (Identity w)   = Width w
widthAlg (Fan w)        = Width w
widthAlg (Above x y)    = Width (gwidth x)
widthAlg (Beside x y)   = Width (gwidth x + gwidth y)
widthAlg (Stretch xs x) = Width (sum xs)

wsAlg :: (WellSized :<: r, Width :<: r) => GAlg r WellSized
wsAlg (Identity w)   = WellSized True
wsAlg (Fan w)        = WellSized True
wsAlg (Above x y)    = WellSized (gwellSized x && gwellSized y && 
                                  gwidth x == gwidth y)
wsAlg (Beside x y)   = WellSized (gwellSized x && gwellSized y)
wsAlg (Stretch xs x) = WellSized (gwellSized x && length xs == gwidth x)
\end{verbatim} 

For composition, we introduce the operator (\textbf{$<$+$>$}), which takes two algebras as inputs and gives back an algebra that returns a composed type:

\begin{verbatim}
(<+>) :: (a :<: r, b :<: r) => GAlg r a -> GAlg r b -> GAlg r (Compose a b)
(<+>) a1 a2 (Identity w)   = (a1 (Identity w), a2 (Identity w))
(<+>) a1 a2 (Fan w)        = (a1 (Fan w), a2 (Fan w))
(<+>) a1 a2 (Above x y)    = (a1 (Above (inter x) (inter y)), 
                              a2 (Above (inter x) (inter y)))
(<+>) a1 a2 (Beside x y)   = (a1 (Beside (inter x) (inter y)), 
                              a2 (Beside (inter x) (inter y)))
(<+>) a1 a2 (Stretch xs x) = (a1 (Stretch xs (inter x)), 
                              a2 (Stretch xs (inter x)))
\end{verbatim} 

\subsection{Modular Reifiable Matching}

\section{Related Work}


\section{Conclusion}


\begin{thebibliography}{99}

\bibitem{1}
Jeremy Gibbons, Nicolas Wu, \textit{Folding Domain-Specific Languages: Deep and Shallow Embeddings}. \hskip 1em plus 0.5em minus 0.4em\relax ICFP' 14, September 1-6, 2014, Gothenburg, Sweden.

\bibitem{2}


\end{thebibliography}

\end{document}
